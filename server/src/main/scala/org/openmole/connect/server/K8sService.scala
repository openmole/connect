package org.openmole.connect.server

import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import org.openmole.connect.server.DB.UUID
import org.openmole.connect.shared.Data
import org.openmole.connect.shared.Data.*
import skuber.LabelSelector.dsl.*
import skuber.PersistentVolume.AccessMode
import skuber.*
import skuber.api.client.KubernetesClient
import skuber.apps.v1.Deployment
import skuber.json.format.*
import skuber.json.networking.format.*
import skuber.networking.{Ingress, IngressList}

import scala.collection.immutable.List
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.*
import scala.concurrent.{Await, ExecutionContextExecutor, Future}

object K8sService:

  object Namespace:
    val openmole = "openmole"
  //val connect = "connect"

  //  object Ceph:
  //    val storageClassName = "rook-ceph-block"

  def toPodInfo(pod: Pod) =
    val containerStatus = pod.status.flatMap(_.containerStatuses.headOption)

    val st =
      containerStatus.flatMap(_.state).map:
        case w: Container.Waiting => Data.PodInfo.Status.Waiting(w.reason.getOrElse(""))
        case r: Container.Running => Data.PodInfo.Status.Running(r.startedAt.map(_.toEpochSecond).getOrElse(0L))
        case t: Container.Terminated => Data.PodInfo.Status.Terminated(t.message.getOrElse(""), t.finishedAt.map { _.toEpochSecond }.getOrElse(0L))

    // Using the added metadata label to get the podName (if any) instead of the actual podName which is now generated by the deployment
    // Should we rename it deploymentName?
    PodInfo(
      pod.name,
      st,
      containerStatus.map(_.restartCount),
      pod.metadata.creationTimestamp.map(_.toEpochSecond),
      pod.status.flatMap(_.podIP),
      DB.user(pod.metadata.labels.getOrElse("podName", "")).map(_.email)
    )

  def listPods = withK8s: k8s =>
    val allPodsMapFut: Future[PodList] = k8s.listInNamespace[PodList]("openmole")//k8s.listSelected[PodList](LabelSelector.IsEqualRequirement("app","openmole"))
    val allPodsFuture: Future[List[Pod]] = allPodsMapFut.map(_.items)

    allPodsFuture map { _.map(toPodInfo) }


  def withK8s[T](kubeAction: KubernetesClient => Future[T]) =

    implicit val system: ActorSystem = ActorSystem()
    implicit val materializer: ActorMaterializer = ActorMaterializer()
    implicit val dispatcher: ExecutionContextExecutor = system.dispatcher
    val k8s = k8sInit

    Await.result(kubeAction(k8s), Duration.Inf)

  def getIngress = withK8s: k8s =>

    //println("get Ingres")
    implicit val system: ActorSystem = ActorSystem()
    implicit val materializer: ActorMaterializer = ActorMaterializer()
    implicit val dispatcher: ExecutionContextExecutor = system.dispatcher

    val allIngressMapFut: Future[ListResource[Ingress]] = k8s.listInNamespace[IngressList] ("ingress-nginx")
    val allIngressFuture: Future[List[Ingress]] = allIngressMapFut map { allIngressMap => allIngressMap.items }

    def listIngress(ingresses: List[Ingress]) = ingresses.headOption

    allIngressFuture map { ingresses => listIngress(ingresses) }

  def ingressIP: Option[String] =
    getIngress.flatMap { i =>
      i.status.flatMap {
        _.loadBalancer.flatMap {
          _.ingress.headOption.flatMap {
            _.ip
          }
        }
      }
    }

  def createOpenMOLEContainer(version: String) =
    // Create the openMOLE container with the volume and SecurityContext privileged (necessary for singularity).
    // see also https://kubernetes.io/docs/concepts/security/pod-security-standards/
    Container(
      name = "openmole",
      image = s"openmole/openmole:${version}",
      command = List("bin/bash", "-c", "openmole-docker --port 80 --password password --remote --mem 1G --workspace /var/openmole/.openmole"),
      volumeMounts = List(Volume.Mount(name = "data", mountPath = "/var/openmole/")),
      securityContext = Some(SecurityContext(privileged = Some(true))),
      imagePullPolicy = Container.PullPolicy.Always
    ).exposePort(80)

  def createPersistentVolumeClaim(pvcName: String, storage: String, storageClassName: Option[String]) =
    def metadata(name: String) = ObjectMeta(name, namespace = Namespace.openmole, labels = Map("app" -> Namespace.openmole))

    PersistentVolumeClaim(
      metadata = metadata(pvcName),
      spec =
        Some(
          PersistentVolumeClaim.Spec(
            //volumeName = Some(pvName),
            storageClassName = storageClassName,
            accessModes = List(AccessMode.ReadWriteOnce),
            resources = Some(Resource.Requirements(requests = Map("storage" -> storage))
            ),//"20Gi"
          )
        )
    )

  def deployOpenMOLE(k8sService: K8sService, uuid: UUID, omVersion: String, storage: String) =
    withK8s: k8s =>
      val podName = uuid.value
      val pvcName = s"pvc-${podName}"
      //val pvName = s"pv-${podName}"

      val pvc = createPersistentVolumeClaim(pvcName, storage, k8sService.storageClassName)

      val openMOLESelector: LabelSelector = LabelSelector.IsEqualRequirement("app", "openmole")
      val openMOLEContainer = createOpenMOLEContainer(omVersion)

      val openMOLELabel = "app" -> "openmole"

      // Adding a metadata label to store the deloyment name (called podName for historical reasons)
      // The actual podName is now generated by the deployment
      // Should we rename it deploymentName?
      val openMOLETemplate = Pod.Template.Spec
        .named("openmole")
        .addContainer(openMOLEContainer)
        .addVolume(Volume(name = "data", source = Volume.PersistentVolumeClaimRef(claimName = pvcName)))
        .addLabel(openMOLELabel)
        .addLabel("podName" -> podName)

      val desiredCount = 1

      // https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/
      val openMOLEDeployment =
        Deployment(
          metadata = ObjectMeta(name=podName),
          spec = Some(
            Deployment.Spec(
              replicas = Some(desiredCount),
              selector = openMOLESelector,
              template = openMOLETemplate,
              strategy = Some(Deployment.Strategy.Recreate)
            )
          )
        )
      //        .withReplicas(desiredCount)
      //        .withTemplate(openMOLETemplate)
      //        .withLabelSelector(openMOLESelector)

      // Creating the openmole deployment
      k8s.usingNamespace(Namespace.openmole) create pvc
      val createdDeploymentFut = k8s.usingNamespace(Namespace.openmole) create openMOLEDeployment

      createdDeploymentFut recoverWith {
        case ex: K8SException if (ex.status.code.contains(409)) =>
          k8s.get[Deployment](openMOLEDeployment.name).flatMap { curr =>
            val updated = openMOLEDeployment.withResourceVersion(curr.metadata.resourceVersion)
            k8s update updated
          }
      }


  def stopOpenMOLEPod(uuid: UUID) = withK8s: k8s =>
    k8s.usingNamespace(Namespace.openmole).get[Deployment](uuid.value) map { d =>
      k8s.usingNamespace(Namespace.openmole) update d.withReplicas(0)
    }


  def startOpenMOLEPod(uuid: UUID) =
    withK8s { k8s =>
      k8s.usingNamespace(Namespace.openmole).get[Deployment](uuid.value) map { d =>
        k8s.usingNamespace(Namespace.openmole) update d.withReplicas(1)
      }
    }

  def updateOpenMOLEPod(uuid: UUID, newVersion: String) =
    withK8s { k8s =>
      k8s.usingNamespace(Namespace.openmole).get[Deployment](uuid.value) map { d =>
        val container = createOpenMOLEContainer(newVersion)
        k8s.usingNamespace(Namespace.openmole) update d.updateContainer(container)
      }
    }


  // FIXME test with no pv name
  def updateOpenMOLEPersistentVolumeStorage(uuid: UUID, newStorage: String, storageClassName: Option[String]) =
    withK8s { k8s =>
      k8s.usingNamespace(Namespace.openmole).get[PersistentVolumeClaim](s"pvc-${uuid.value}").map{pvc=>
        pvc.spec.map {spec=>
          spec.volumeName.map{ pvName=>
            println(s"updating openmole spec with ${uuid.value} and ${pvName} for ${newStorage}")
            k8s.usingNamespace(Namespace.openmole).update(createPersistentVolumeClaim(s"pvc-${uuid.value}", newStorage, storageClassName))
          }
        }
      }
    }

  def deleteOpenMOLE(uuid: UUID) =
    //k8s.usingNamespace(Namespace.openmole).deleteAllSelected[PodList](LabelSelector.IsEqualRequirement("podName",uuid.value))
    withK8s: k8s =>
      val deleteOptions = DeleteOptions(propagationPolicy = Some(DeletePropagation.Foreground))
      k8s.usingNamespace(Namespace.openmole).deleteWithOptions[Deployment](uuid.value, deleteOptions)
      k8s.usingNamespace(Namespace.openmole).delete[PersistentVolumeClaim](s"pvc-${uuid.value}")

//  def deployIfNotDeployedYet(k8sService: K8sService, uuid: UUID, omVersion: String, storage: String) =
//    if !deploymentExists(uuid) then deployOpenMOLE(k8sService, uuid, omVersion, storage)

  private def podInfo(uuid: UUID, podList: List[PodInfo]): Option[PodInfo] =
    podList.find { _.name.contains(uuid.value) }

  // This method was kept to test the LabelSelector method. Is works but requires more API requests => longer
  def podInfo(uuid: UUID): Option[PodInfo] =
    withK8s: k8s =>
      val pods = k8s.usingNamespace(Namespace.openmole).listSelected[PodList](LabelSelector.IsEqualRequirement("podName", uuid.value))
      pods.map { list => list.items.map(toPodInfo).headOption }

//  def isServiceUp(uuid: UUID): Boolean =
//    podInfo(uuid).flatMap { _.status.contains() }.isDefined

  def deploymentExists(uuid: UUID) = podInfo(uuid).isDefined

  def podInfos: Seq[PodInfo] =
    val pods = listPods
    for {
      uuid <- DB.uuids
      podInfo <- podInfo(uuid, pods)
    } yield podInfo

  //def hostIP(uuid: UUID) = podInfo(uuid).flatMap { _.podIP }


case class K8sService(storageClassName: Option[String])
