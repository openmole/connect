package org.openmoleconnect.server

import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import org.openmoleconnect.server.DB.UUID
import shared.Data
import shared.Data._
import skuber.LabelSelector.dsl._
import skuber.PersistentVolume.AccessMode
import skuber._
import skuber.api.client.KubernetesClient
import skuber.apps.v1.Deployment
import skuber.json.format._
import skuber.json.networking.format._
import skuber.networking.{Ingress, IngressList}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._
import scala.concurrent.{Await, Future}

object K8sService {

  object Namespace {
    val openmole = "openmole"
    val connect = "connect"
  }

  object Ceph {
    val storageClassName = "rook-ceph-block"
  }

  def toPodInfoList(pod: Pod) = {
    for {
      stat <- pod.status.toList
      containerStat <- stat.containerStatuses
      state <- containerStat.state
      restarts <- stat.containerStatuses.headOption
      createTime <- pod.metadata.creationTimestamp
      podIP <- stat.podIP
    } yield {
      val st: shared.Data.Status = state match {
        case Container.Waiting(reason) => Waiting(reason.getOrElse(""))
        case _: Container.Running => Data.Running()
        case Container.Terminated(_, _, _, message, _, finishedAt, _) => Data.Terminated(message.getOrElse(""), finishedAt.map {
          _.toEpochSecond
        }.getOrElse(0L))
      }
      // Using the added metadata label to get the podName (if any) instead of the actual podName which is now generated by the deployment
      // Should we rename it deploymentName?
      PodInfo(pod.name, st.value, restarts.restartCount, createTime.toEpochSecond, podIP, DB.email(UUID(pod.metadata.labels.getOrElse("podName", ""))).map {
        _.value
      })
    }
  }
  def listPods = {
    withK8s { k8s =>

      implicit val system = ActorSystem()
      implicit val materializer = ActorMaterializer()
      implicit val dispatcher = system.dispatcher

      val allPodsMapFut: Future[PodList] = k8s.listInNamespace[PodList]("openmole")//k8s.listSelected[PodList](LabelSelector.IsEqualRequirement("app","openmole"))
      val allPodsFuture: Future[List[Pod]] = allPodsMapFut.map(_.items)

      allPodsFuture map { _.flatMap { pod: Pod => toPodInfoList(pod) } }

    }
  }

  def withK8s[T](kubeAction: KubernetesClient => Future[T]) = {

    implicit val system = ActorSystem()
    implicit val materializer = ActorMaterializer()
    implicit val dispatcher = system.dispatcher
    val k8s = k8sInit

    Await.result(kubeAction(k8s), Duration.Inf)
  }

  def getIngress = withK8s { k8s =>

    //println("get Ingres")
    implicit val system = ActorSystem()
    implicit val materializer = ActorMaterializer()
    implicit val dispatcher = system.dispatcher

    val allIngressMapFut: Future[ListResource[Ingress]] = k8s listInNamespace[IngressList] ("ingress-nginx")
    val allIngressFuture: Future[List[Ingress]] = allIngressMapFut map { allIngressMap =>
      allIngressMap.items
    }

    def listIngress(ingresses: List[Ingress]) = ingresses.headOption

    allIngressFuture map { ingresses => listIngress(ingresses) }
  }

  def ingressIP: Option[String] =
    getIngress.flatMap { i =>
      i.status.flatMap {
        _.loadBalancer.flatMap {
          _.ingress.headOption.flatMap {
            _.ip
          }
        }
      }
    }

  def deployOpenMOLE(uuid: UUID) = {
    withK8s { k8s =>
      val podName = uuid.value
      val pvcName = s"pvc-${podName}"
      val pvName = s"pv-${podName}"

      def metadata(name: String) = ObjectMeta(name, namespace = Namespace.openmole, labels = Map("app" -> Namespace.openmole))

      val pvc = PersistentVolumeClaim(
        metadata = metadata(pvcName),
        spec = Some(PersistentVolumeClaim.Spec(
          storageClassName = Some(Ceph.storageClassName),
          accessModes = List(AccessMode.ReadWriteOnce),
          resources = Some(Resource.Requirements(requests = Map("storage" -> "20Gi"))),
        ))
      )
      val openMOLESelector = "app" is "openmole"

      // Create the openMOLE container with the volume and SecurityContext privileged (necessary for singularity).
      // see also https://kubernetes.io/docs/concepts/security/pod-security-standards/
      val openMOLEContainer = Container(
        name = "openmole",
        image = "openmole/openmole",
        command = List("bin/bash", "-c", "openmole-docker --port 80 --password password --remote --mem 1G --workspace /var/openmole/.openmole"),
        volumeMounts = List(Volume.Mount(name = pvName, mountPath = "/var/openmole/")),
        securityContext = Some(SecurityContext(privileged = Some(true))),
      ).exposePort(80)

      val openMOLELabel = "app" -> "openmole"

      // Adding a metadata label to store the deloyment name (called podName for historical reasons)
      // The actual podName is now generated by the deployment
      // Should we rename it deploymentName?
      val openMOLETemplate = Pod.Template.Spec
        .named("openmole")
        .addContainer(openMOLEContainer)
        .addVolume(Volume(name = pvName, source = Volume.PersistentVolumeClaimRef(claimName = pvcName)))
        .addLabel(openMOLELabel)
        .addLabel("podName" -> podName)

      val desiredCount = 1

      // https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/
      val openMOLEDeployment = Deployment(podName)
        .withReplicas(desiredCount)
        .withTemplate(openMOLETemplate)
        .withLabelSelector(openMOLESelector)

      // Creating the openmole deployment
      k8s.usingNamespace(Namespace.openmole) create pvc
      val createdDeploymentFut = k8s.usingNamespace(Namespace.openmole) create openMOLEDeployment

      createdDeploymentFut recoverWith {
        case ex: K8SException if (ex.status.code.contains(409)) => {
          println("It seems the deployment object already exists - retrieving latest version and updating it")
          (k8s get[Deployment] openMOLEDeployment.name) flatMap { curr =>
            println("retrieved latest deployment, now updating")
            val updated = openMOLEDeployment.withResourceVersion(curr.metadata.resourceVersion)
            k8s update updated
          }
        }
      }
    }
  }

  def stopOpenMOLEPod(uuid: UUID) = {
    withK8s { k8s =>
      k8s.usingNamespace(Namespace.openmole).get[Deployment](uuid.value) map { d =>
        k8s.usingNamespace(Namespace.openmole) update d.withReplicas(0)
      }
    }
  }

  def startOpenMOLEPod(uuid: UUID) = {
    withK8s { k8s =>
      k8s.usingNamespace(Namespace.openmole).get[Deployment](uuid.value) map { d =>
        k8s.usingNamespace(Namespace.openmole) update d.withReplicas(1)
      }
    }
  }

  def deleteOpenMOLE(uuid: UUID) = {
    //k8s.usingNamespace(Namespace.openmole).deleteAllSelected[PodList](LabelSelector.IsEqualRequirement("podName",uuid.value))
    withK8s { k8s =>
      val deleteOptions = DeleteOptions(propagationPolicy = Some(DeletePropagation.Foreground))
      k8s.usingNamespace(Namespace.openmole).deleteWithOptions[Deployment](uuid.value, deleteOptions)
      k8s.usingNamespace(Namespace.openmole).delete[PersistentVolumeClaim](s"pvc-${uuid.value}")
    }
  }

  def deployIfNotDeployedYet(uuid: UUID) = {
    if (!isDeploymentExists(uuid))
      deployOpenMOLE(uuid)
  }

  private def podInfo(uuid: UUID, podList: List[PodInfo]): Option[PodInfo] =
    podList.find {
      _.name.contains(uuid.value)
    }

  // This method was kept to test the LabelSelector method. Is works but requires more API requests => longer
  private def podInfo(uuid: UUID): Option[PodInfo] = {
    println("podInfo: " + uuid)
    withK8s {
      k8s =>
        val pods = k8s.usingNamespace(Namespace.openmole).listSelected[PodList](LabelSelector.IsEqualRequirement("podName", uuid.value))
        println("PODINFO select for " + uuid.value)
        pods.map { list =>
          println("podinfo for " + uuid.value + " - " + list.items.size)
          list.items.flatMap { pod => toPodInfoList(pod) }.headOption
        }
    }
  }

  def isServiceUp(uuid: UUID): Boolean = {
    podInfo(uuid).map {
      _.status
    } == Some(Running)
  }

  def isDeploymentExists(uuid: UUID) = podInfo(uuid).isDefined

  def podInfos: Seq[PodInfo] = {
    val pods = listPods
    for {
      uuid <- DB.uuids
      podInfo <- podInfo(uuid, pods)
    } yield (podInfo)
  }

  def hostIP(uuid: UUID) = {
    podInfo(uuid).map {
      _.podIP
    }
  }
}